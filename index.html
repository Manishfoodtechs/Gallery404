
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>three.js - pointerlock controls</title>
        <script src="jquery.min.js"></script>
        <script src="init.js"></script>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <body>
        <script src="three.min.js"></script>
        <script src="PointerLockControls.js"></script>
        <script src="BinaryLoader.js"></script>

        <div id="blocker">
            <div id="instructions">
                <span style="font-size:46px">Welcome to Gallery 3D,<br /> <span style="font-size:28px">the world's first interactive <br />and explorable web-based 3D gallery.</span><br /> <br /><span style="font-size:18px">Click anywhere on the screen to start. </span>
                <br />
                <br />
                <span style="font-size:32px">(W, A, S, D = Move, MOUSE = Look around)</span>
            </div>
        </div>
        <div id ="controls">
            <div id="q" class="key">Q<br /><span class="key-info">Turn Left</span></div><div id="w" class="key">W<br /><span class="key-info">Forward</span></div><div id="e" class="key">E<br /><span class="key-info">Turn Right</span></div> <br />
            <div id="a" class="key">A<br /><span class="key-info">Move Left</span></div><div id="s" class="key">S<br /><span class="key-info">Backwards</span></div><div id="d" class="key">D<br /><span class="key-info">Move Right</span></div>
        </div>

        <script>

            var camera, scene, renderer;
            var geometry, material, mesh;
            var controls,time = Date.now();

            var objects = [];

            var ray;

            var blocker = document.getElementById( 'blocker' );
            var instructions = document.getElementById( 'instructions' );

            // http://www.html5rocks.com/en/tutorials/pointerlock/intro/

            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

            if ( havePointerLock ) {

                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

                        controls.enabled = true;

                        blocker.style.display = 'none';

                    } else {

                        controls.enabled = false;

                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';

                        instructions.style.display = '';

                    }

                }

                var pointerlockerror = function ( event ) {

                    instructions.style.display = '';

                }

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {

                    instructions.style.display = 'none';

                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

                    if ( /Firefox/i.test( navigator.userAgent ) ) {

                        var fullscreenchange = function ( event ) {

                            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

                                document.removeEventListener( 'fullscreenchange', fullscreenchange );
                                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

                                element.requestPointerLock();
                            }

                        }

                        document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                        document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

                        element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

                        element.requestFullscreen();

                    } else {

                        element.requestPointerLock();

                    }

                }, false );

            } else {

                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

            }

            init();
            animate();

            function init() {

                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );

                scene = new THREE.Scene();
                scene.fog = new THREE.Fog( 0xffffff, 0, 750 );

                var light = new THREE.DirectionalLight( 0xffffff, 1.5 );
                light.position.set( 1, 1, 1 );
                scene.add( light );

                var light = new THREE.DirectionalLight( 0xffffff, 0.75 );
                light.position.set( -1, - 0.5, -1 );
                scene.add( light );

                controls = new THREE.PointerLockControls( camera );
                scene.add( controls.getObject() );

                ray = new THREE.Raycaster();
                ray.ray.direction.set( 0, -1, 0 );

                // floor

                geometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
                geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

                for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {

                    var vertex = geometry.vertices[ i ];
                    vertex.x += 10;
                    vertex.y += 2;
                    vertex.z += 10;

                }

                for ( var i = 0, l = geometry.faces.length; i < l; i ++ ) {

                    var face = geometry.faces[ i ];
                    face.vertexColors[ 0 ] = new THREE.Color(0xffffff);
                    face.vertexColors[ 1 ] = new THREE.Color(0xdddddd);
                    face.vertexColors[ 2 ] = new THREE.Color(0xffffff);
                    face.vertexColors[ 3 ] = new THREE.Color(0xdddddd);

                }

                material = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );

                mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );

                // objects

                  geometry = new THREE.CubeGeometry( 80, 100, 5 );


                for ( var i = 0, l = geometry.faces.length; i < l; i ++ ) {

                    var face = geometry.faces[ i ];
                    face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
                    face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
                    face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
                    face.vertexColors[ 3 ] = new THREE.Color().setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

                }

                //for ( var i = 0; i < 4; i ++ ) {

                  /*  material = new THREE.MeshPhongMaterial( { specular: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors } );

                    var mesh = new THREE.Mesh( geometry, material );
                    mesh.position.x = 0;
                    mesh.position.y = 10;
                    mesh.position.z = -100;
                    mesh.rotation.y = 0

                    var mesh2 = new THREE.Mesh( geometry, material);
                    mesh2.position.x = -80;
                    mesh2.position.y = 0;
                    mesh2.position.z = -75;
                    mesh2.rotation.y += 90;

                    scene.add(mesh);
                    scene.add(mesh2);
                    material.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

                    objects.push( mesh );*/

                // }


                //////////////////////////////////
                //** -- JSON OBJECT LOADER -- **//
                //////////////////////////////////

                    // Note: if imported model appears too dark,
                    //   add an ambient light in this file
                    //   and increase values in model's exported .js file
                    //    to e.g. "colorAmbient" : [0.75, 0.75, 0.75]
                   var jsonLoader = new THREE.JSONLoader();
                    jsonLoader.load( "models/koons.js", addModelToScene );
                    // addModelToScene function is called back after model has loaded
                    
                    // var ambientLight = new THREE.AmbientLight([0.75, 0.75, 0.75]);
                    // scene.add(ambientLight);
                    
                

                function addModelToScene( geometry, materials ) 
                {

                    var path = "/textures/cube/SwedishRoyalCastle/";
                var format = '.jpg';
                var urls = [
                        path + 'px' + format, path + 'nx' + format,
                        path + 'py' + format, path + 'ny' + format,
                        path + 'pz' + format, path + 'nz' + format
                    ];

                var reflectionCube = THREE.ImageUtils.loadTextureCube( urls );
                reflectionCube.format = THREE.RGBFormat;
                    var refractionCube = new THREE.Texture( reflectionCube.image, new THREE.CubeRefractionMapping() );
                refractionCube.format = THREE.RGBFormat;
                    //console.log(floorMaterial);
                    // var objectMaterial = new THREE.MeshFaceMaterial(newMaterial);
                    var material = new THREE.MeshLambertMaterial( { color: 0xffee00, ambient: 0x996600, envMap: refractionCube, refractionRatio: 0.95 } );
                    koons = new THREE.Mesh( geometry, material );
                    koons.scale.set(10,10,10);
                    koons.position.x = 0;
                    koons.position.y = 0;
                    koons.position.z = 300;
                    scene.add( koons );
                }


                

                renderer = new THREE.WebGLRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );

                document.body.appendChild( renderer.domElement );

                

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                requestAnimationFrame( animate );

                //

                controls.isOnObject( false );

                ray.ray.origin.copy( controls.getObject().position );
                ray.ray.origin.y -= 10;

                var intersections = ray.intersectObjects( objects );

                if ( intersections.length > 0 ) {

                    var distance = intersections[ 0 ].distance;

                    if ( distance > 0 && distance < 10 ) {

                        controls.isOnObject( true );

                    }

                }

                controls.update( Date.now() - time );

                renderer.render( scene, camera );

                time = Date.now();

            }

        </script>
    </body>
</html>
